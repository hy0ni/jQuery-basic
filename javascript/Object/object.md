## 객체(Object)
<br>

> 객체 (= Object)

- 객체는 일종의 배열인데, 인덱스가 Number타입이 아니라 String타입인 배열이다.<br>
  인덱스가 숫자가 아니므로 배열을 구성하는 각 요소간에 앞뒤라던가 좌우라던가 하는 순서성이 없다.

```javascript
            0  1  2  3  4    =>    Number타입
      var arr = [1, 2, 3, 4, 5];
```

<br>

    배열(=순차배열)과 객체(=연관배열)의 차이
    순차배열 (Sequential Array)                    인덱스가 0부터 시작하는 정수로 이뤄진 배열.
                                                  인덱스가 정수이므로 배열요소간에 순서성, 길이(마지막 인덱스번호 + 1)가 있다.


    연관배열 (Associative Array)                   인덱스가 문자열로 이뤄진 배열.
                                                  배열요소간에 순서성이나 길이가 없다.

<br>

> **객체 만들기 #1 {'인덱스':'데이터'}**

```javascript
      var obj = {“name”:”효니”, “job”:”퍼블리셔”}; // JavaScript Object Notification, JSON

      console.log( obj[“name”] );

      인덱스를 구성하는 문자열이 변수 명명규칙에 맞는 경우에 한해서, 아래와 같이 축약표기가 가능하다.

      console.log( obj.name );
```

<br>

- 객체 탐색

```javascript
객체 대해서는 수행할 수 없는 작업
  for( var i=0; i<arr.length; i+=1 ) {
  }

for문의 특수한 형태로 for-in 구문을 사용하면 객체를 탐색할 수 있다.

  for( var idx in obj ) {
    // idx변수에는 객체의 문자열 인덱스가 하나씩 뽑혀나오면서 루프를 돌게 된다.
  }
```

<br>

- 메써드(method), 프로퍼티(property), this키워드

  객체는 인덱스마다 서로 다른 데이터를 담을 수 있는데, 당연히 함수도 담을 수 있다.<br>
  객체의 어떤 인덱스에 함수가 들어있는 경우, 그 인덱스를 가르켜서 메써드(method)라고 부른다.<br>
  객체의 인덱스중에 함수가 아닌것을 통칭해서 프로퍼티(property)라고 부른다.<br>
  메써드 안에서 this 라는 키워드를 사용하면 그 메써드를 소유한 원본객체를 나타낸다.<br>
  메써드가 아닌 함수에서 this 키워드는 전역 컨텍스트 객체(=window객체)를 나타낸다.<br>

<br>

- 추상화 (abstraction)<br>
  현실에 존재하는 모든 사물은 여러가지 속성으로 이뤄져 있다.

      ex) 병원에서 환자를 나타내고자 할때에는..
      성명: 
      주민등록번호:
      성별:
      
      ex) 학교에서 학생을 나타내고자 할때에는..
      이름:
      학번:
      성적:
      
      ex) 사람을 나타내고자 할때에는..
      {
        이름: “효니”,
        성별: “여성”,
        나이: “34”,
        키: “176”,
        체중: “52”,
        직업: “퍼블리셔”
      }

  현실에 존재하는 대상의 속성을 컴퓨터로 옮겨 표현하는 것을 추상화(abstraction)라고 하는데,<br>
  프로그램이라는게 결국 현실의 문제를 해결하는데에 도움을 주는 것임을 생각해보면<br>
  현실의 대상을 프로그램에서 표현하는 추상화 과정은 빈번하게 일어나는 작업이다.<br>
  추상화를 거친 대상은 객체의 형태로 표현하는게 일반적이다.

  <br>

> **객체 만들기 #2**

```javascript
      var person1 = {“name”:”홍길동”, “age”:341, “sex”:”남성”, “job”:”도둑놈”, “hello”:”거 반갑수다”};
      var person2 = {“name”:”김영희”, “age”:18, “sex”:”여성”, “job”:”고등학생”, “hello”:”안뇽하세용~”};
```

  이 두 객체는 담고 있는 내용이 달라보이지만 객체를 구성하는 키가 동일하다.<br>
  이런 경우를 가르켜서 “시그니쳐가 같다”라고 말한다.<br>
  프로그램을 개발하면서 시그니쳐가 같은 객체를 여러개 생성해야 하는 상황이 종종 생긴다.<br>
  <br>
  시그니쳐가 같은 객체를 여러개 생성할 때에는 JSON방식은 적합하지 않고, 객체생성자함수를 이용한다.

<br>

```javascript
    객체생성자함수
      function Person( name, age, sex, job, hello ) {
        // this = {“name”:name, “age”:age, “sex”:sex, “job”:job, “hello”:hello}
        this[“name”] = name;
        this[“age”] = age;
        this.sex = sex;
        this.job = job;
        this.hello = hello;
      }
      var p1 = new Person( “홍길동”, 341, “남성”, “도둑놈”, “거 반갑수다” );
      var p2 = new Person( “김영희”, 18, “여성”, “고등학생”, “안뇽하세용~” );
```

  <span style="background:#dcffe4">
  객체생성자함수는 반드시 new 키워드와 함께 호출해야 한다.<br>
  객체생성자함수는 이름의 첫글자를 대문자로 표기해서 이 함수는 new 키워드와 함께 호출해야 함을 나타내는 관례가 있다.<br>
  객체생성자함수 안에서 this 키워드는 빈 객체를 나타낸다.<br> 함수 안에서는 비어있는 this 객체를 채워나가는 식으로 객체를 생성한다.<br>

  객체생성자함수를 실수로 new 키워드 없이 호출하면, 전역 컨텍스트 객체(=window객체)를 오염시키게 되므로 절대 주의해야 한다.<br>
  </span>

  <br>
  <br>

- 객체생성자함수 안에서 메써드를 만드는 경우의 문제

객체를 구성하는 프로퍼티는 객체마다 각자 다를 수 있는데, 메써드는 모든 객체가 같은 내용의 함수를 사용한다.<br>
객체를 만들때마다 같은 내용의 함수가 매번 새로 만들어지면서, 모든 객체가 각자 자기 함수를 독자적으로 갖고 있게 되면서, 메모리 낭비된다.<br>
결론적으로 메써드는 객체생성자함수 안에서 만들어서는 안된다.<br>

객체생성자함수의 prototype이라는 키(=객체)안에 메써드를 만들면,
모든 객체가 공유하는 함수인데 메모리에는 1개만 존재하는 함수를 만들 수 있다.<br>

<br>
<br>

- 프로토타입 체인

자바스크립트에서 모든 객체는 심지어 빈 객체라 할지라도 반드시 __proto__ 라는 이름의 키가 존재한다.<br>
  이 키는 객체 형태다.<br>
  __proto__ 가 언제 사용되냐면, 객체에 존재하지 않는 키를 사용하려고 시도할 때 __proto__ 객체 안에서 같은 이름의 키를 찾아서, 존재면 사용가능한것으로 본다.<br>

  객체의 __proto__ 키는 객체생성자함수의 prototype 키가 그 출처다.<br>
  객체.__proto__ === 객체생성자함수.prototype 이라는 관계가 성립한다.<br>

<br>
<br>

- 객체를 확장

 일단 사람은 사람인데, 학번이라는 속성을 추가로 부여해서, 학생인 사람을 만들어낸 과정을 확장extends(=상속inherits)이라고 한다.

<br>
<br>

- 객체지향? vs 절차지향? vs 함수형?

프로그램의 각 기능조각들을 객체단위로 분리해서 최종적으로 객체들을 조립해가는 식으로 프로그램을 만드는 개발방법.
  